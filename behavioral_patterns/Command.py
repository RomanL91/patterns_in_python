    # Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, 
# позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, 
# а также поддерживать отмену операций.

    # Проблема
# Представьте, что вы работаете над программой текстового редактора. Дело как раз подошло к разработке панели управления. 
# Вы создали класс красивых Кнопок и хотите использовать его для всех кнопок приложения, 
# начиная от панели управления, заканчивая простыми кнопками в диалогах.

# Все эти кнопки, хоть и выглядят схоже, но делают разные вещи. Поэтому возникает вопрос: 
# куда поместить код обработчиков кликов по этим кнопкам? 
# Самым простым решением было бы создать подклассы для каждой кнопки и переопределить в них метод действия под разные задачи.

# Но скоро стало понятно, что такой подход никуда не годится. 
# Во-первых, получается очень много подклассов. 
# Во-вторых, код кнопок, относящийся к графическому интерфейсу, начинает зависеть от классов бизнес-логики, 
# которая довольно часто меняется.

# Но самое обидное ещё впереди. 
# Ведь некоторые операции, например, «сохранить», можно вызывать из нескольких мест: нажав кнопку на панели управления, 
# вызвав контекстное меню или просто нажав клавиши Ctrl+S. Когда в программе были только кнопки, 
# код сохранения имелся только в подклассе SaveButton. Но теперь его придётся продублировать ещё в два класса.

    # Решение
# Хорошие программы обычно структурированы в виде слоёв. Самый распространённый пример — слои пользовательского интерфейса и бизнес-логики. 
# Первый всего лишь рисует красивую картинку для пользователя. Но когда нужно сделать что-то важное, 
# интерфейс «просит» слой бизнес-логики заняться этим.

# В реальности это выглядит так: один из объектов интерфейса напрямую вызывает метод одного из объектов бизнес-логики, 
# передавая в него какие-то параметры.

# Паттерн Команда предлагает больше не отправлять такие вызовы напрямую. Вместо этого каждый вызов, отличающийся от других, 
# следует завернуть в собственный класс с единственным методом, который и будет осуществлять вызов. 
# Такие объекты называют командами.

# К объекту интерфейса можно будет привязать объект команды, который знает, кому и в каком виде следует отправлять запросы. 
# Когда объект интерфейса будет готов передать запрос, он вызовет метод команды, а та — позаботится обо всём остальном.

# Классы команд можно объединить под общим интерфейсом c единственным методом запуска. 
# После этого одни и те же отправители смогут работать с различными командами, не привязываясь к их классам. 
# Даже больше: команды можно будет взаимозаменять на лету, изменяя итоговое поведение отправителей.

# Параметры, с которыми должен быть вызван метод объекта получателя, можно загодя сохранить в полях объекта-команды. Благодаря этому, 
# объекты, отправляющие запросы, могут не беспокоиться о том, чтобы собрать необходимые для получателя данные. 
# Более того, они теперь вообще не знают, кто будет получателем запроса. Вся эта информация скрыта внутри команды.

    # Аналогия из жизни
# Вы заходите в ресторан и садитесь у окна. К вам подходит вежливый официант и принимает заказ, записывая все пожелания в блокнот. 
# Откланявшись, он уходит на кухню, где вырывает лист из блокнота и клеит на стену. 
# Далее лист оказывается в руках повара, который читает содержание заказа и готовит заказанные блюда.

# В этом примере вы являетесь отправителем, официант с блокнотом — командой, а повар — получателем. 
# Как и в паттерне, вы не соприкасаетесь напрямую с поваром. Вместо этого вы отправляете заказ с официантом, 
# который самостоятельно «настраивает» повара на работу. С другой стороны, повар не знает, кто конкретно послал ему заказ. 
# Но это ему безразлично, так как вся необходимая информация есть в листе заказа.


# Применимость: Паттерн можно часто встретить в Python-коде, особенно когда нужно откладывать выполнение команд, 
# выстраивать их в очереди, а также хранить историю и делать отмену.


from __future__ import annotations
from abc import ABC, abstractmethod


class Command(ABC):
    """
    Интерфейс Команды объявляет метод для выполнения команд.
    """

    @abstractmethod
    def execute(self) -> None:
        pass


class SimpleCommand(Command):
    """
    Некоторые команды способны выполнять простые операции самостоятельно.
    """

    def __init__(self, payload: str) -> None:
        self._payload = payload

    def execute(self) -> None:
        print(f"SimpleCommand: See, I can do simple things like printing"
              f"({self._payload})")


class ComplexCommand(Command):
    """
    Но есть и команды, которые делегируют более сложные операции другим
    объектам, называемым «получателями».
    """

    def __init__(self, receiver: Receiver, a: str, b: str) -> None:
        """
        Сложные команды могут принимать один или несколько объектов-получателей
        вместе с любыми данными о контексте через конструктор.
        """

        self._receiver = receiver
        self._a = a
        self._b = b

    def execute(self) -> None:
        """
        Команды могут делегировать выполнение любым методам получателя.
        """

        print("ComplexCommand: Complex stuff should be done by a receiver object", end="")
        self._receiver.do_something(self._a)
        self._receiver.do_something_else(self._b)


class Receiver:
    """
    Классы Получателей содержат некую важную бизнес-логику. Они умеют выполнять
    все виды операций, связанных с выполнением запроса. Фактически, любой класс
    может выступать Получателем.
    """

    def do_something(self, a: str) -> None:
        print(f"\nReceiver: Working on ({a}.)", end="")

    def do_something_else(self, b: str) -> None:
        print(f"\nReceiver: Also working on ({b}.)", end="")


class Invoker:
    """
    Отправитель связан с одной или несколькими командами. Он отправляет запрос
    команде.
    """

    _on_start = None
    _on_finish = None

    """
    Инициализация команд.
    """

    def set_on_start(self, command: Command):
        self._on_start = command

    def set_on_finish(self, command: Command):
        self._on_finish = command

    def do_something_important(self) -> None:
        """
        Отправитель не зависит от классов конкретных команд и получателей.
        Отправитель передаёт запрос получателю косвенно, выполняя команду.
        """

        print("Invoker: Does anybody want something done before I begin?")
        if isinstance(self._on_start, Command):
            self._on_start.execute()

        print("Invoker: ...doing something really important...")

        print("Invoker: Does anybody want something done after I finish?")
        if isinstance(self._on_finish, Command):
            self._on_finish.execute()


if __name__ == "__main__":
    """
    Клиентский код может параметризовать отправителя любыми командами.
    """

    invoker = Invoker()
    invoker.set_on_start(SimpleCommand("Say Hi!"))
    receiver = Receiver()
    invoker.set_on_finish(ComplexCommand(
        receiver, "Send email", "Save report"))

    invoker.do_something_important()
    