    # Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, 
# позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, 
# а также поддерживать отмену операций.

    # Проблема
# Представьте, что вы работаете над программой текстового редактора. Дело как раз подошло к разработке панели управления. 
# Вы создали класс красивых Кнопок и хотите использовать его для всех кнопок приложения, 
# начиная от панели управления, заканчивая простыми кнопками в диалогах.

# Все эти кнопки, хоть и выглядят схоже, но делают разные вещи. Поэтому возникает вопрос: 
# куда поместить код обработчиков кликов по этим кнопкам? 
# Самым простым решением было бы создать подклассы для каждой кнопки и переопределить в них метод действия под разные задачи.

# Но скоро стало понятно, что такой подход никуда не годится. 
# Во-первых, получается очень много подклассов. 
# Во-вторых, код кнопок, относящийся к графическому интерфейсу, начинает зависеть от классов бизнес-логики, 
# которая довольно часто меняется.

# Но самое обидное ещё впереди. 
# Ведь некоторые операции, например, «сохранить», можно вызывать из нескольких мест: нажав кнопку на панели управления, 
# вызвав контекстное меню или просто нажав клавиши Ctrl+S. Когда в программе были только кнопки, 
# код сохранения имелся только в подклассе SaveButton. Но теперь его придётся продублировать ещё в два класса.

    # Решение
# Хорошие программы обычно структурированы в виде слоёв. Самый распространённый пример — слои пользовательского интерфейса и бизнес-логики. 
# Первый всего лишь рисует красивую картинку для пользователя. Но когда нужно сделать что-то важное, 
# интерфейс «просит» слой бизнес-логики заняться этим.

# В реальности это выглядит так: один из объектов интерфейса напрямую вызывает метод одного из объектов бизнес-логики, 
# передавая в него какие-то параметры.

# Паттерн Команда предлагает больше не отправлять такие вызовы напрямую. Вместо этого каждый вызов, отличающийся от других, 
# следует завернуть в собственный класс с единственным методом, который и будет осуществлять вызов. 
# Такие объекты называют командами.

# К объекту интерфейса можно будет привязать объект команды, который знает, кому и в каком виде следует отправлять запросы. 
# Когда объект интерфейса будет готов передать запрос, он вызовет метод команды, а та — позаботится обо всём остальном.

# Классы команд можно объединить под общим интерфейсом c единственным методом запуска. 
# После этого одни и те же отправители смогут работать с различными командами, не привязываясь к их классам. 
# Даже больше: команды можно будет взаимозаменять на лету, изменяя итоговое поведение отправителей.

# Параметры, с которыми должен быть вызван метод объекта получателя, можно загодя сохранить в полях объекта-команды. Благодаря этому, 
# объекты, отправляющие запросы, могут не беспокоиться о том, чтобы собрать необходимые для получателя данные. 
# Более того, они теперь вообще не знают, кто будет получателем запроса. Вся эта информация скрыта внутри команды.

    # Аналогия из жизни
# Вы заходите в ресторан и садитесь у окна. К вам подходит вежливый официант и принимает заказ, записывая все пожелания в блокнот. 
# Откланявшись, он уходит на кухню, где вырывает лист из блокнота и клеит на стену. 
# Далее лист оказывается в руках повара, который читает содержание заказа и готовит заказанные блюда.

# В этом примере вы являетесь отправителем, официант с блокнотом — командой, а повар — получателем. 
# Как и в паттерне, вы не соприкасаетесь напрямую с поваром. Вместо этого вы отправляете заказ с официантом, 
# который самостоятельно «настраивает» повара на работу. С другой стороны, повар не знает, кто конкретно послал ему заказ. 
# Но это ему безразлично, так как вся необходимая информация есть в листе заказа.