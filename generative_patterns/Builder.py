# Строитель — это порождающий паттерн проектирования, 
# который позволяет создавать сложные объекты пошагово. Строитель даёт возможность 
# использовать один и тот же код строительства для получения разных 
# представлений объектов.

# # Проблема
# Представьте сложный объект, требующий кропотливой пошаговой инициализации 
# множества полей и вложенных объектов. Код инициализации таких объектов обычно 
# спрятан внутри монструозного конструктора с десятком параметров. 
# Либо ещё хуже — распылён по всему клиентскому коду.

# Например, давайте подумаем о том, как создать объект Дом. Чтобы построить стандартный дом, 
# нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. 
# Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро?

# Самое простое решение — расширить класс Дом, создав подклассы для всех комбинаций параметров дома. 
# Проблема такого подхода — это громадное количество классов, которые вам придётся создать. 
# Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё 
# больше и больше классов для перечисления всех возможных вариантов.

# Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. 
# Вы можете создать гигантский конструктор Дома, принимающий уйму параметров для контроля над 
# создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме.

# Большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть 
# монструозно из-за длинного списка параметров. К примеру, далеко не каждый дом имеет бассейн, 
# поэтому параметры, связанные с бассейнами, будут простаивать бесполезно в 99% случаев.

# РЕШЕНИЕ:
# Паттерн Строитель предлагает вынести конструирование объекта за пределы его собственного 
# класса, поручив это дело отдельным объектам, называемым строителями.

# Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, построитьСтены, вставитьДвери и другие). 
# Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. 
# Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

# Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов. 
# Например, деревянный дом потребует строительства стен из дерева, а каменный — из камня.

# В этом случае вы можете создать несколько классов строителей, выполняющих одни и те же шаги по-разному. 
# Используя этих строителей в одном и том же строительном процессе, 
# вы сможете получать на выходе различные объекты.

# Например, один строитель делает стены из дерева и стекла, другой из камня и железа, 
# третий из золота и бриллиантов. Вызвав одни и те же шаги строительства, в первом случае вы получите 
# обычный жилой дом, во втором — маленькую крепость, а в третьем — роскошное жилище. Замечу, что код, который вызывает 
# шаги строительства, должен работать со строителями через общий интерфейс, чтобы их можно было свободно взаимозаменять.

    # Директор
    # Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый директором. 
    # В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.


from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Any


class Builder(ABC):
    """
    Интерфейс Строителя объявляет создающие методы для различных частей объектов
    Продуктов.
    """

    @property
    @abstractmethod
    def product(self) -> None:
        pass

    @abstractmethod
    def produce_part_a(self) -> None:
        pass

    @abstractmethod
    def produce_part_b(self) -> None:
        pass

    @abstractmethod
    def produce_part_c(self) -> None:
        pass


class ConcreteBuilder1(Builder):
    """
    Классы Конкретного Строителя следуют интерфейсу Строителя и предоставляют
    конкретные реализации шагов построения. Ваша программа может иметь несколько
    вариантов Строителей, реализованных по-разному.
    """

    def __init__(self) -> None:
        """
        Новый экземпляр строителя должен содержать пустой объект продукта,
        который используется в дальнейшей сборке.
        """
        self.reset()

    def reset(self) -> None:
        self._product = Product1()

    @property
    def product(self) -> Product1:
        """
        Конкретные Строители должны предоставить свои собственные методы
        получения результатов. Это связано с тем, что различные типы строителей
        могут создавать совершенно разные продукты с разными интерфейсами.
        Поэтому такие методы не могут быть объявлены в базовом интерфейсе
        Строителя (по крайней мере, в статически типизированном языке
        программирования).

        Как правило, после возвращения конечного результата клиенту, экземпляр
        строителя должен быть готов к началу производства следующего продукта.
        Поэтому обычной практикой является вызов метода сброса в конце тела
        метода getProduct. Однако такое поведение не является обязательным, вы
        можете заставить своих строителей ждать явного запроса на сброс из кода
        клиента, прежде чем избавиться от предыдущего результата.
        """
        product = self._product
        self.reset()
        return product

    def produce_part_a(self) -> None:
        self._product.add("PartA1")

    def produce_part_b(self) -> None:
        self._product.add("PartB1")

    def produce_part_c(self) -> None:
        self._product.add("PartC1")


class Product1():
    """
    Имеет смысл использовать паттерн Строитель только тогда, когда ваши продукты
    достаточно сложны и требуют обширной конфигурации.

    В отличие от других порождающих паттернов, различные конкретные строители
    могут производить несвязанные продукты. Другими словами, результаты
    различных строителей могут не всегда следовать одному и тому же интерфейсу.
    """

    def __init__(self) -> None:
        self.parts = []

    def add(self, part: Any) -> None:
        self.parts.append(part)

    def list_parts(self) -> None:
        print(f"Product parts: {', '.join(self.parts)}", end="")


class Director:
    """
    Директор отвечает только за выполнение шагов построения в определённой
    последовательности. Это полезно при производстве продуктов в определённом
    порядке или особой конфигурации. Строго говоря, класс Директор необязателен,
    так как клиент может напрямую управлять строителями.
    """

    def __init__(self) -> None:
        self._builder = None

    @property
    def builder(self) -> Builder:
        return self._builder

    @builder.setter
    def builder(self, builder: Builder) -> None:
        """
        Директор работает с любым экземпляром строителя, который передаётся ему
        клиентским кодом. Таким образом, клиентский код может изменить конечный
        тип вновь собираемого продукта.
        """
        self._builder = builder

    """
    Директор может строить несколько вариаций продукта, используя одинаковые
    шаги построения.
    """

    def build_minimal_viable_product(self) -> None:
        self.builder.produce_part_a()

    def build_full_featured_product(self) -> None:
        self.builder.produce_part_a()
        self.builder.produce_part_b()
        self.builder.produce_part_c()


if __name__ == "__main__":
    """
    Клиентский код создаёт объект-строитель, передаёт его директору, а затем
    инициирует процесс построения. Конечный результат извлекается из объекта-
    строителя.
    """

    director = Director()
    builder = ConcreteBuilder1()
    director.builder = builder

    print("Standard basic product: ")
    director.build_minimal_viable_product()
    builder.product.list_parts()

    print("\n")

    print("Standard full featured product: ")
    director.build_full_featured_product()
    builder.product.list_parts()

    print("\n")

    # Помните, что паттерн Строитель можно использовать без класса Директор.
    print("Custom product: ")
    builder.produce_part_a()
    builder.produce_part_b()
    builder.product.list_parts()
    