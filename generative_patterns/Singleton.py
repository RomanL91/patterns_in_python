# Одиночка — это порождающий паттерн проектирования, который гарантирует, 
# что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

# Проблема:
# Одиночка решает сразу две проблемы, нарушая принцип единственной ответственности класса.

# 1.Гарантирует наличие единственного экземпляра класса. 
# Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.
# Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. 
# В этом случае хотелось бы получить старый объект, вместо создания нового.
# Такое поведение невозможно реализовать с помощью обычного конструктора, 
# так как конструктор класса всегда возвращает новый объект.

# 2. Предоставляет глобальную точку доступа. Это не просто глобальная переменная, 
# через которую можно достучаться к определённому объекту. 
# Глобальные переменные не защищены от записи, поэтому любой код может подменять их 
# значения без вашего ведома.
 
# Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, 
# который решает проблему №1, а также иметь к нему простой и доступный интерфейс.

# РЕШЕНИЕ:
# Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и 
# создать публичный статический метод, который и будет контролировать жизненный 
# цикл объекта-одиночки.

# Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому 
# методу. Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и 
# тот же объект.


class SingletonMeta(type):
    """
    В Python класс Одиночка можно реализовать по-разному. Возможные способы
    включают себя базовый класс, декоратор, метакласс. Мы воспользуемся
    метаклассом, поскольку он лучше всего подходит для этой цели.
    """

    _instances = {}

    def __call__(cls, *args, **kwargs):
        """
        Данная реализация не учитывает возможное изменение передаваемых
        аргументов в `__init__`.
        """
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class Singleton(metaclass=SingletonMeta):
    def some_business_logic(self):
        """
        Наконец, любой одиночка должен содержать некоторую бизнес-логику,
        которая может быть выполнена на его экземпляре.
        """

        # ...


if __name__ == "__main__":
    # Клиентский код.

    s1 = Singleton()
    s2 = Singleton()

    if id(s1) == id(s2):
        print("Singleton works, both variables contain the same instance.")
    else:
        print("Singleton failed, variables contain different instances.")


# Многопоточный ОДИНОЧКА
# from threading import Lock, Thread


# class SingletonMeta(type):
#     """
#     Это потокобезопасная реализация класса Singleton.
#     """

#     _instances = {}

#     _lock: Lock = Lock()
#     """
#     У нас теперь есть объект-блокировка для синхронизации потоков во время
#     первого доступа к Одиночке.
#     """

#     def __call__(cls, *args, **kwargs):
#         """
#         Данная реализация не учитывает возможное изменение передаваемых
#         аргументов в `__init__`.
#         """
#         # Теперь представьте, что программа была только-только запущена.
#         # Объекта-одиночки ещё никто не создавал, поэтому несколько потоков
#         # вполне могли одновременно пройти через предыдущее условие и достигнуть
#         # блокировки. Самый быстрый поток поставит блокировку и двинется внутрь
#         # секции, пока другие будут здесь его ожидать.
#         with cls._lock:
#             # Первый поток достигает этого условия и проходит внутрь, создавая
#             # объект-одиночку. Как только этот поток покинет секцию и освободит
#             # блокировку, следующий поток может снова установить блокировку и
#             # зайти внутрь. Однако теперь экземпляр одиночки уже будет создан и
#             # поток не сможет пройти через это условие, а значит новый объект не
#             # будет создан.
#             if cls not in cls._instances:
#                 instance = super().__call__(*args, **kwargs)
#                 cls._instances[cls] = instance
#         return cls._instances[cls]


# class Singleton(metaclass=SingletonMeta):
#     value: str = None
#     """
#     Мы используем это поле, чтобы доказать, что наш Одиночка действительно
#     работает.
#     """

#     def __init__(self, value: str) -> None:
#         self.value = value

#     def some_business_logic(self):
#         """
#         Наконец, любой одиночка должен содержать некоторую бизнес-логику,
#         которая может быть выполнена на его экземпляре.
#         """


# def test_singleton(value: str) -> None:
#     singleton = Singleton(value)
#     print(singleton.value)


# if __name__ == "__main__":
#     # Клиентский код.

#     print("If you see the same value, then singleton was reused (yay!)\n"
#           "If you see different values, "
#           "then 2 singletons were created (booo!!)\n\n"
#           "RESULT:\n")

#     process1 = Thread(target=test_singleton, args=("FOO",))
#     process2 = Thread(target=test_singleton, args=("BAR",))
#     process1.start()
#     process2.start()







